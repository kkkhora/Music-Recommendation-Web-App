/* c8 ignore start */
// 64 KiB (same size chrome slice theirs blob into Uint8array's)
<<<<<<< HEAD
const POOL_SIZE = 65536;

if (!globalThis.ReadableStream) {
  try {
    Object.assign(globalThis, require('stream/web'))
  } catch (error) {
		// TODO: Remove when only supporting node >= 16.5.0
=======
const POOL_SIZE = 65536

if (!globalThis.ReadableStream) {
  // `node:stream/web` got introduced in v16.5.0 as experimental
  // and it's preferred over the polyfilled version. So we also
  // suppress the warning that gets emitted by NodeJS for using it.
  try {
    const process = require('node:process')
    const { emitWarning } = process
    try {
      process.emitWarning = () => {}
      Object.assign(globalThis, require('node:stream/web'))
      process.emitWarning = emitWarning
    } catch (error) {
      process.emitWarning = emitWarning
      throw error
    }
  } catch (error) {
    // fallback to polyfill implementation
>>>>>>> 2790dd6be12be7d3fe3896bcbbb6ec1de18d19a9
    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))
  }
}

try {
<<<<<<< HEAD
  const {Blob} = require('buffer')
  if (Blob && !Blob.prototype.stream) {
		Blob.prototype.stream = function name(params) {
			let position = 0;
			const blob = this;

			return new ReadableStream({
				type: 'bytes',
				async pull(ctrl) {
					const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE));
					const buffer = await chunk.arrayBuffer();
					position += buffer.byteLength;
					ctrl.enqueue(new Uint8Array(buffer))

					if (position === blob.size) {
						ctrl.close()
					}
				}
			})
		}
	}
=======
  // Don't use node: prefix for this, require+node: is not supported until node v14.14
  // Only `import()` can use prefix in 12.20 and later
  const { Blob } = require('buffer')
  if (Blob && !Blob.prototype.stream) {
    Blob.prototype.stream = function name (params) {
      let position = 0
      const blob = this

      return new ReadableStream({
        type: 'bytes',
        async pull (ctrl) {
          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))
          const buffer = await chunk.arrayBuffer()
          position += buffer.byteLength
          ctrl.enqueue(new Uint8Array(buffer))

          if (position === blob.size) {
            ctrl.close()
          }
        }
      })
    }
  }
>>>>>>> 2790dd6be12be7d3fe3896bcbbb6ec1de18d19a9
} catch (error) {}
/* c8 ignore end */
